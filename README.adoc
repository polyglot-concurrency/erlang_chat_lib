:source-highlighter: pygments
:icons: font

= Chat application

== How to use

Asume this users are present:

[source,shell]
----
> {ok, Pid} = db:start(). <1>
{ok,<0.176.0>}
> db:add_user("jhon", "aaaa"). <2>
ok
> db:add_user("ana", "bbbb").
ok
> db:add_user("mike", "cccc").
ok
> db:add_user("will", "dddd").
ok
> db:add_group("group2", "ana"). <3>
ok
> db:add_user_to_group("group2", "mike"). <4>
ok
> db:add_user_to_group("group2", "jhon").
ok
> db:add_user_to_group("group2", "will").
----

<1> To start the db server.

<2> Adding 3 users, the first parameter is the name, the secondone is the password.

<3> Creating a group, using the db interface (the recomended way is using the domain API). The user
creating the group is automatically added to it.

<4> Adding 3 others users to the group.

=== Login/logout client

[source,shell]
----
> {_, Pmike} = domain:login("mike", "cccc").
{ok,<0.183.0>}
> domain:logout(Pmike).
ok
----

=== One to One chat

[source,shell]
----
> {_, Pana} = domain:login("ana", "bbbb").
{ok,<0.181.0>}
> {_, Pmike} = domain:login("mike", "cccc").
{ok,<0.183.0>}
> domain:send_msg(Pana, "mike", "hello mike").
ok
> {ok, Msgs} = domain:get_msgs(Pmike).
{ok,[{"ana","hello mike"}]}
----

=== Group chat

The following description is based on the test cases of the project.

[source,erlang]
----
    {_, Pana} = domain:login("ana", "bbbb"), <1>
    {_, Pmike} = domain:login("mike", "cccc"),
    {_, Pjhon} = domain:login("jhon", "aaaa"),

    domain:send_msg_to_group(Pana, "group2", "hello mike"), <2>
    domain:send_msg_to_group(Pana, "group2", "hello again"),
    domain:send_msg_to_group(Pjhon, "group2", "hello"),

    domain:send_msg(Pjhon, "will", "what's up?"), <3>

    {_, Pwill} = domain:login("will", "dddd"), <4>

    {ok, Msgs} = domain:get_msgs(Pmike), <5>
    {ok, MsgsPjhon} = domain:get_msgs(Pjhon),
    {ok, MsgsPana} = domain:get_msgs(Pana),
    {ok, MsgsPwill} = domain:get_msgs(Pwill),

    [
     ?_assertEqual([
                    {"group2:ana", "hello mike"}
                   , {"group2:ana", "hello again"}
                   , {"group2:jhon", "hello"}
                   ], Msgs) <6>
    ,?_assertEqual([
                    {"group2:ana", "hello mike"}
                   , {"group2:ana", "hello again"}
                   ], MsgsPjhon)
    ,?_assertEqual([
                    {"group2:jhon", "hello"}
                   ], MsgsPana)
    ,?_assertEqual([
                    {"group2:ana", "hello mike"}
                   , {"group2:ana", "hello again"}
                   , {"group2:jhon", "hello"}
                   , {"jhon", "what's up?"}
                   ], MsgsPwill)

    ].
----

<1> Login 3 users, the session is represented by
a Pid of an chat_user module process.

<2> Sending a group message to "group2" group. The sender is the first parameter,
and the lastone the message content.

<3> Sending a normal message to "will".

<4> Now is "will" loged in, the previos messages where stored,
and now are sended to this just created chat_user.

<5> Checking the messages of each user.

<6> "mike" messages, the format of the messages: the first component is
the sender name (when the messges came from a group chat it is included
its name too), the second is the message text.

=== Get list of users (be able to send message to each user)

[source,shell]
----
> domain:get_all_users_names().
["ana","jhon","mike"]
----

=== Cluster support (need to connect 2 servers and each server should know about all chats/users)

=== Help details with what commands can be used


== Build

    $ rebar3 compile

== Apply dialyzer

    $ rebar3 dialyzer apps/chat/src/domain.erl apps/chat/src/db.erl
